<ui:composition xmlns="http://www.w3.org/1999/xhtml" xmlns:f="http://java.sun.com/jsf/core"
                xmlns:h="http://java.sun.com/jsf/html" xmlns:ui="http://java.sun.com/jsf/facelets"
                template="../template/template.xhtml">
    <ui:param name="Votre portefeuille" value="Portfolio"/>
    <ui:define name="body">
	
		<meta charset="utf-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>Financial | Chart.js</title>
		<script src="https://cdn.jsdelivr.net/npm/luxon@1.24.1"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js@3.0.0-alpha"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@0.2.1"></script>
	
		<link rel="stylesheet" type="text/css" href="style.css"/>
		

		
		<div style="width:1000px">
			<canvas id="chart"></canvas>
		</div>
		<div>
			Bar Type:
			<select id="type">
				<option value="candlestick" selected="selected">Candlestick</option>
				<option value="ohlc">OHLC</option>
			</select>
			
		
			
			<button id="update">Update</button>
			<button id="randomizeData">Randomize Data</button>
		</div>
		
		<h:outputScript name="functions.js" target="head" />
		<h:outputScript>
   
       (function (global, factory) {
			typeof exports === 'object' &amp;&amp;typeof module !== 'undefined' ? factory(require('chart.js')) :
			typeof define === 'function' &amp;&amp;define.amd ? define(['chart.js'], factory) :
			(global = global || self, factory(global.Chart));
			}(this, (function (Chart) { 'use strict';

			Chart = Chart &amp;&amp; Object.prototype.hasOwnProperty.call(Chart, 'default') ? Chart['default'] : Chart;

			const helpers = Chart.helpers;

			Chart.defaults.financial = {
				label: '',

				hover: {
					mode: 'label'
				},

				datasets: {
					categoryPercentage: 0.8,
					barPercentage: 0.9,
					animation: {
						numbers: {
							type: 'number',
							properties: ['x', 'y', 'base', 'width', 'height', 'open', 'high', 'low', 'close']
						}
					}
				},

				scales: {
					x: {
						type: 'time',
						distribution: 'series',
						offset: true,
						ticks: {
							major: {
								enabled: true,
							},
							fontStyle: context => context.tick.major ? 'bold' : undefined,
							source: 'data',
							maxRotation: 0,
							autoSkip: true,
							autoSkipPadding: 75,
							sampleSize: 100
						}
					},
					y: {
						type: 'linear'
					}
				},

				tooltips: {
					intersect: false,
					mode: 'index',
					callbacks: {
						label(tooltipItem, data) {
							const dataset = data.datasets[tooltipItem.datasetIndex];
							const point = dataset.data[tooltipItem.index];

							if (!helpers.isNullOrUndef(point.y)) {
								return Chart.defaults.tooltips.callbacks.label(tooltipItem, data);
							}

							const {o, h, l, c} = point;

							return 'O: ' + o + '  H: ' + h + '  L: ' + l + '  C: ' + c;
						}
					}
				}
			};

			function parseFloatBar(obj, item, vScale, i) {
				const low = vScale.parse(obj.l, i);
				const high = vScale.parse(obj.h, i);
				const min = Math.min(low, high);
				const max = Math.max(low, high);
				let barStart = min;
				let barEnd = max;

				if (Math.abs(min) > Math.abs(max)) {
					barStart = max;
					barEnd = min;
				}

				// Store `barEnd` (furthest away from origin) as parsed value,
				// to make stacking straight forward
				item[vScale.axis] = barEnd;

				item._custom = {
					barStart,
					barEnd,
					min,
					max
				};
			}

			/**
			 * This class is based off controller.bar.js from the upstream Chart.js library
			 */
			class FinancialController extends Chart.controllers.bar {

				/**
				 * Overriding since we use {o, h, l, c}
				 * @protected
				 */
				parseObjectData(meta, data, start, count) {
					const {iScale, vScale} = meta;
					const parsed = [];
					let i, ilen, item, obj;
					for (i = start, ilen = start + count; i &lt; ilen; ++i) {
						obj = data[i];
						item = {};
						item[iScale.axis] = iScale.parseObject(obj, iScale.axis, i);
						parseFloatBar(obj, item, vScale, i);
						parsed.push(item);
					}
					return parsed;
				}

				/**
				 * Implement this ourselves since it doesn't handle high and low values
				 * https://github.com/chartjs/Chart.js/issues/7328
				 * @protected
				 */
				getMinMax(scale) {
					const meta = this._cachedMeta;
					const _parsed = meta._parsed;

					if (scale.axis === 'x') {
						return {min: _parsed[0].x, max: _parsed[_parsed.length - 1].x};
					}

					let min = Number.POSITIVE_INFINITY;
					let max = Number.NEGATIVE_INFINITY;
					for (let i = 0; i  &lt;_parsed.length; i++) {
						const custom = _parsed[i]._custom;
						min = Math.min(min, custom.min);
						max = Math.max(max, custom.max);
					}
					return {min, max};
				}

				/**
				 * @protected
				 */
				calculateElementProperties(index, reset, options) {
					const me = this;
					const vscale = me._getValueScale();
					const base = vscale.getBasePixel();
					const horizontal = vscale.isHorizontal();
					const ruler = me._ruler || me._getRuler();
					const vpixels = me._calculateBarValuePixels(index, options);
					const ipixels = me._calculateBarIndexPixels(index, ruler, options);
					const datasets = me.chart.data.datasets;
					const indexData = datasets[me.index].data[index];

					return {
						horizontal,
						base: reset ? base : vpixels.base,
						x: horizontal ? reset ? base : vpixels.head : ipixels.center,
						y: horizontal ? ipixels.center : reset ? base : vpixels.head,
						height: horizontal ? ipixels.size : undefined,
						width: horizontal ? undefined : ipixels.size,
						open: vscale.getPixelForValue(indexData.o),
						high: vscale.getPixelForValue(indexData.h),
						low: vscale.getPixelForValue(indexData.l),
						close: vscale.getPixelForValue(indexData.c)
					};
				}

			}

			FinancialController.prototype.dataElementType = Chart.elements.Financial;

			const helpers$1 = Chart.helpers;
			const globalOpts = Chart.defaults;

			globalOpts.elements.financial = {
				color: {
					up: 'rgba(80, 160, 115, 1)',
					down: 'rgba(215, 85, 65, 1)',
					unchanged: 'rgba(90, 90, 90, 1)',
				}
			};

			/**
			 * Helper function to get the bounds of the bar regardless of the orientation
			 * @param {Rectangle} bar the bar
			 * @param {boolean} [useFinalPosition]
			 * @return {object} bounds of the bar
			 * @private
			 */
			function getBarBounds(bar, useFinalPosition) {
				const {x, y, base, width, height} = bar.getProps(['x', 'low', 'high', 'width', 'height'], useFinalPosition);

				let left, right, top, bottom, half;

				if (bar.horizontal) {
					half = height / 2;
					left = Math.min(x, base);
					right = Math.max(x, base);
					top = y - half;
					bottom = y + half;
				} else {
					half = width / 2;
					left = x - half;
					right = x + half;
					top = Math.min(y, base);
					bottom = Math.max(y, base);
				}

				return {left, top, right, bottom};
			}

			function inRange(bar, x, y, useFinalPosition) {
				const skipX = x === null;
				const skipY = y === null;
				const bounds = !bar || (skipX &amp;&amp; skipY) ? false : getBarBounds(bar, useFinalPosition);

				return bounds
					&amp;&amp; (skipX || x &lt;= bounds.left &amp;&amp; x &lt;= bounds.right)
					&amp;&amp;(skipY || y &lt;= bounds.top &amp;&amp; y &lt;= bounds.bottom);
			}

			class FinancialElement extends Chart.Element {

				height() {
					return this.base - this.y;
				}

				inRange(mouseX, mouseY, useFinalPosition) {
					return inRange(this, mouseX, mouseY, useFinalPosition);
				}

				inXRange(mouseX, useFinalPosition) {
					return inRange(this, mouseX, null, useFinalPosition);
				}

				inYRange(mouseY, useFinalPosition) {
					return inRange(this, null, mouseY, useFinalPosition);
				}

				getRange(axis) {
					return axis === 'x' ? this.width / 2 : this.height / 2;
				}

				getCenterPoint(useFinalPosition) {
					const {x, low, high} = this.getProps(['x', 'low', 'high'], useFinalPosition);
					return {
						x,
						y: (high + low) / 2
					};
				}

				tooltipPosition(useFinalPosition) {
					const {x, open, close} = this.getProps(['x', 'open', 'close'], useFinalPosition);
					return {
						x,
						y: (open + close) / 2
					};
				}
			}

			const helpers$2 = Chart.helpers;
			const globalOpts$1 = Chart.defaults;

			globalOpts$1.elements.candlestick = helpers$2.merge({}, [globalOpts$1.elements.financial, {
				borderColor: globalOpts$1.elements.financial.color.unchanged,
				borderWidth: 1,
			}]);

			class CandlestickElement extends FinancialElement {
				draw(ctx) {
					const me = this;

					const {x, open, high, low, close} = me;

					let borderColors = me.borderColor;
					if (typeof borderColors === 'string') {
						borderColors = {
							up: borderColors,
							down: borderColors,
							unchanged: borderColors
						};
					}

					let borderColor;
					if (close &lt; open) {
						borderColor = helpers$2.valueOrDefault(borderColors ? borderColors.up : undefined, globalOpts$1.elements.candlestick.borderColor);
						ctx.fillStyle = helpers$2.valueOrDefault(me.color ? me.color.up : undefined, globalOpts$1.elements.candlestick.color.up);
					} else if (close > open) {
						borderColor = helpers$2.valueOrDefault(borderColors ? borderColors.down : undefined, globalOpts$1.elements.candlestick.borderColor);
						ctx.fillStyle = helpers$2.valueOrDefault(me.color ? me.color.down : undefined, globalOpts$1.elements.candlestick.color.down);
					} else {
						borderColor = helpers$2.valueOrDefault(borderColors ? borderColors.unchanged : undefined, globalOpts$1.elements.candlestick.borderColor);
						ctx.fillStyle = helpers$2.valueOrDefault(me.color ? me.color.unchanged : undefined, globalOpts$1.elements.candlestick.color.unchanged);
					}

					ctx.lineWidth = helpers$2.valueOrDefault(me.borderWidth, globalOpts$1.elements.candlestick.borderWidth);
					ctx.strokeStyle = helpers$2.valueOrDefault(borderColor, globalOpts$1.elements.candlestick.borderColor);

					ctx.beginPath();
					ctx.moveTo(x, high);
					ctx.lineTo(x, Math.min(open, close));
					ctx.moveTo(x, low);
					ctx.lineTo(x, Math.max(open, close));
					ctx.stroke();
					ctx.fillRect(x - me.width / 2, close, me.width, open - close);
					ctx.strokeRect(x - me.width / 2, close, me.width, open - close);
					ctx.closePath();
				}
			}

			Chart.defaults.candlestick = Chart.helpers.merge({}, Chart.defaults.financial);

			class CandlestickController extends FinancialController {

				updateElements(elements, start, mode) {
					for (let i = 0; i &lt; elements.length; i++) {
						const me = this;
						const dataset = me.getDataset();
						const index = start + i;
						const options = me.resolveDataElementOptions(index, mode);

						const baseProperties = me.calculateElementProperties(index, mode === 'reset', options);
						const properties = {
							...baseProperties,
							datasetLabel: dataset.label || '',
							// label: '', // to get label value please use dataset.data[index].label

							// Appearance
							color: dataset.color,
							borderColor: dataset.borderColor,
							borderWidth: dataset.borderWidth,
						};
						properties.options = options;

						me.updateElement(elements[i], index, properties, mode);
					}
				}

			}

			CandlestickController.prototype.dataElementType = CandlestickElement;
			Chart.controllers.candlestick = CandlestickController;

			const helpers$3 = Chart.helpers;
			const globalOpts$2 = Chart.defaults;

			globalOpts$2.elements.ohlc = helpers$3.merge({}, [globalOpts$2.elements.financial, {
				lineWidth: 2,
				armLength: null,
				armLengthRatio: 0.8,
			}]);

			class OhlcElement extends FinancialElement {
				draw(ctx) {
					const me = this;

					const {x, open, high, low, close} = me;

					const armLengthRatio = helpers$3.valueOrDefault(me.armLengthRatio, globalOpts$2.elements.ohlc.armLengthRatio);
					let armLength = helpers$3.valueOrDefault(me.armLength, globalOpts$2.elements.ohlc.armLength);
					if (armLength === null) {
						// The width of an ohlc is affected by barPercentage and categoryPercentage
						// This behavior is caused by extending controller.financial, which extends controller.bar
						// barPercentage and categoryPercentage are now set to 1.0 (see controller.ohlc)
						// and armLengthRatio is multipled by 0.5,
						// so that when armLengthRatio=1.0, the arms from neighbour ohcl touch,
						// and when armLengthRatio=0.0, ohcl are just vertical lines.
						armLength = me.width * armLengthRatio * 0.5;
					}

					if (close &lt; open) {
						ctx.strokeStyle = helpers$3.valueOrDefault(me.color ? me.color.up : undefined, globalOpts$2.elements.ohlc.color.up);
					} else if (close > open) {
						ctx.strokeStyle = helpers$3.valueOrDefault(me.color ? me.color.down : undefined, globalOpts$2.elements.ohlc.color.down);
					} else {
						ctx.strokeStyle = helpers$3.valueOrDefault(me.color ? me.color.unchanged : undefined, globalOpts$2.elements.ohlc.color.unchanged);
					}
					ctx.lineWidth = helpers$3.valueOrDefault(me.lineWidth, globalOpts$2.elements.ohlc.lineWidth);

					ctx.beginPath();
					ctx.moveTo(x, high);
					ctx.lineTo(x, low);
					ctx.moveTo(x - armLength, open);
					ctx.lineTo(x, open);
					ctx.moveTo(x + armLength, close);
					ctx.lineTo(x, close);
					ctx.stroke();
				}
			}

			Chart.defaults.ohlc = Chart.helpers.merge({}, Chart.defaults.financial);
			Chart.defaults.set('ohlc', {
				datasets: {
					barPercentage: 1.0,
					categoryPercentage: 1.0
				}
			});

			class OhlcController extends FinancialController {

				updateElements(elements, start, mode) {
					for (let i = 0; i &lt; elements.length; i++) {
						const me = this;
						const dataset = me.getDataset();
						const index = start + i;
						const options = me.resolveDataElementOptions(index, mode);

						const baseProperties = me.calculateElementProperties(index, mode === 'reset', options);
						const properties = {
							...baseProperties,
							datasetLabel: dataset.label || '',
							lineWidth: dataset.lineWidth,
							armLength: dataset.armLength,
							armLengthRatio: dataset.armLengthRatio,
							color: dataset.color,
						};
						properties.options = options;

						me.updateElement(elements[i], index, properties, mode);
					}
				}

			}

			OhlcController.prototype.dataElementType = OhlcElement;
			Chart.controllers.ohlc = OhlcController;

			})));
   
</h:outputScript>
		<h:outputScript>
   
     var barCount = 10;
		var initialDateStr = '01 Apr 2017 00:00 Z';

		var ctx = document.getElementById('chart').getContext('2d');
		ctx.canvas.width = 1000;
		ctx.canvas.height = 250;
		var chart = new Chart(ctx, {
			type: 'candlestick',
			data: {
				datasets: [{
					label: 'CHRT - Chart.js Corporation',
					data: getRandomData(initialDateStr, barCount)
				}]
			},
			options: {
				scales: {
					x: {
						afterBuildTicks: function(scale) {
							const majorUnit = scale._majorUnit;
							const ticks = scale.ticks;
							const firstTick = ticks[0];
							let i, ilen, val, tick, currMajor, lastMajor;

							val = luxon.DateTime.fromMillis(ticks[0].value);
							if ((majorUnit === 'minute' &amp;&amp; val.second === 0)
									|| (majorUnit === 'hour' &amp;&amp; val.minute === 0)
									|| (majorUnit === 'day' &amp;&amp; val.hour === 9)
									|| (majorUnit === 'month' &amp;&amp; val.day &lt;= 3 &amp;&amp; val.weekday === 1)
									|| (majorUnit === 'year' &amp;&amp; val.month === 0)) {
								firstTick.major = true;
							} else {
								firstTick.major = false;
							}
							lastMajor = val.get(majorUnit);

							for (i = 1, ilen = ticks.length; i &lt; ilen; i++) {
								tick = ticks[i];
								val = luxon.DateTime.fromMillis(tick.value);
								currMajor = val.get(majorUnit);
								tick.major = currMajor !== lastMajor;
								lastMajor = currMajor;
							}
							return ticks;
						}
					}
				}
			}
		});

		var getRandomInt = function(max) {
			return Math.floor(Math.random() * Math.floor(max));
		};

		function randomNumber(min, max) {
			return Math.random() * (max - min) + min;
		}

		function randomBar(date, lastClose) {
			var open = randomNumber(lastClose * 0.95, lastClose * 1.05).toFixed(2);
			var close = randomNumber(open * 0.95, open * 1.05).toFixed(2);
			var high = randomNumber(Math.max(open, close), Math.max(open, close) * 1.1).toFixed(2);
			var low = randomNumber(Math.min(open, close) * 0.9, Math.min(open, close)).toFixed(2);
			return {
				t: date.valueOf(),
				o: open,
				h: high,
				l: low,
				c: close
			};

		}

		function getRandomData(dateStr, count) {
			var date = luxon.DateTime.fromRFC2822(dateStr);
			var data = [randomBar(date, 30)];
			while (data.length &lt; count) {
				date = date.plus({days: 1});
				if (date.weekday &lt;= 5) {
					data.push(randomBar(date, data[data.length - 1].c));
				}
			}
			
			return data;
		}

		var update = function() {
			var dataset = chart.config.data.datasets[0];

			// candlestick vs ohlc
			var type = document.getElementById('type').value;
			dataset.type = type;

		
		

		

			chart.update();
		};

		document.getElementById('update').addEventListener('click', update);

		document.getElementById('randomizeData').addEventListener('click', function() {
			chart.data.datasets.forEach(function(dataset) {
				dataset.data = getRandomData(initialDateStr, barCount);
			});
			update();
		});
  
</h:outputScript>
		

</ui:define>
</ui:composition>